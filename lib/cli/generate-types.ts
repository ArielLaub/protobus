import * as fs from 'fs';
import * as path from 'path';
import { loadConfig, resolvePath } from './config';

/**
 * Generate TypeScript types from .proto files
 *
 * This uses protobufjs-cli (pbjs/pbts) to generate types and then
 * applies transforms to make them more ergonomic for protobus usage.
 */
export async function generateTypes(cwd: string = process.cwd()): Promise<void> {
    const config = loadConfig(cwd);
    const protoDir = resolvePath(config.protoDir, cwd);
    const typesOutput = resolvePath(config.typesOutput, cwd);

    // Ensure output directory exists
    const outputDir = path.dirname(typesOutput);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    // Create temp directory for intermediate files
    const tempDir = path.join(cwd, '.protobus-temp');
    if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
    }

    const tempJsOutput = path.join(tempDir, 'proto.js');
    const tempTsOutput = path.join(tempDir, 'proto.d.ts');

    try {
        // Dynamic import of protobufjs-cli
        let pbjs: any;
        let pbts: any;

        try {
            pbjs = require('protobufjs-cli/pbjs');
            pbts = require('protobufjs-cli/pbts');
        } catch {
            console.error('Error: protobufjs-cli is required for type generation.');
            console.error('Install it with: npm install --save-dev protobufjs-cli');
            process.exit(1);
        }

        const protoGlob = path.join(protoDir, '*.proto');

        // Check if proto directory exists
        if (!fs.existsSync(protoDir)) {
            console.error(`Error: Proto directory not found: ${protoDir}`);
            console.error(`Create the directory and add your .proto files, or configure "protoDir" in package.json`);
            process.exit(1);
        }

        // Check if proto files exist
        const protoFiles = fs.readdirSync(protoDir).filter(f => f.endsWith('.proto'));
        if (protoFiles.length === 0) {
            console.error(`Error: No .proto files found in ${protoDir}`);
            process.exit(1);
        }

        console.log(`Found ${protoFiles.length} proto file(s) in ${protoDir}`);

        // Step 1: Generate JS with pbjs
        console.log('Generating JavaScript definitions...');
        await new Promise<void>((resolve, reject) => {
            pbjs.main([
                '--target', 'static',
                '--no-convert',
                '--no-encode',
                '--no-decode',
                '--no-verify',
                '--no-delimited',
                '--no-beautify',
                '--no-create',
                '--keep-case',
                '-w', 'commonjs',
                '--es6',
                '-o', tempJsOutput,
                protoGlob,
            ], (err: Error | null) => {
                if (err) reject(err);
                else resolve();
            });
        });

        // Step 2: Generate TypeScript definitions with pbts
        console.log('Generating TypeScript definitions...');
        await new Promise<void>((resolve, reject) => {
            pbts.main([
                '-o', tempTsOutput,
                '--no-comments',
                '-m',
                tempJsOutput,
            ], (err: Error | null) => {
                if (err) reject(err);
                else resolve();
            });
        });

        // Step 3: Transform the TypeScript output
        console.log('Transforming types for protobus...');
        let tsContent = fs.readFileSync(tempTsOutput, 'utf-8');
        tsContent = transformTypes(tsContent);

        // Write final output
        fs.writeFileSync(typesOutput, tsContent);

        console.log(`Types generated successfully: ${typesOutput}`);

    } finally {
        // Cleanup temp directory
        if (fs.existsSync(tempDir)) {
            fs.rmSync(tempDir, { recursive: true, force: true });
        }
    }
}

/**
 * Transform the generated TypeScript to be more ergonomic for protobus
 */
function transformTypes(content: string): string {
    let result = content;

    // Add header with lint disables and Long type alias
    result = `/* eslint-disable */
/* tslint:disable */
// Auto-generated by protobus CLI - do not edit manually
type Long = number;

${result}`;

    // Remove methods with callback param (we use promises)
    result = result.replace(/^.*\b(callback)\b.*$/gm, '');

    // Remove interface and service constructors
    result = result.replace(/^.*\b(constructor)\b.*$/gm, '');

    // Convert service classes to interfaces (stop extending $protobuf.rpc.Service)
    result = result.replace(/class .* extends \$protobuf.rpc.Service /gm, 'interface Service ');

    // Export all interfaces
    result = result.replace(/\binterface /gm, 'export interface ');

    // Export all classes as ambient declarations
    result = result.replace(/\bclass /gm, 'export declare class ');

    // Export all namespaces
    result = result.replace(/\s\snamespace /gm, '  export namespace ');

    // Export all enums
    result = result.replace(/\benum /gm, 'export enum ');
    result = result.replace(/\bconst enum /gm, 'export const enum ');

    // Remove public keyword (not needed in interfaces)
    result = result.replace(/\bpublic /gm, '');

    // Make service methods return interfaces (IFoo instead of Foo)
    const interfaceRegex = /Promise<[^>]*\./g;
    const positions: number[] = [];
    while (interfaceRegex.exec(result) !== null) {
        positions.push(interfaceRegex.lastIndex);
    }
    // Insert 'I' at each position (in reverse to not mess up indices)
    for (let i = positions.length - 1; i >= 0; i--) {
        const pos = positions[i];
        result = result.slice(0, pos) + 'I' + result.slice(pos);
    }

    // Add ServiceName constants to each namespace that contains a Service interface
    result = result.replace(
        /export namespace (\w+) \{([^}]*export interface Service[^}]*)\}/gs,
        (match, namespaceName, content) => {
            if (content.includes("export const ServiceName =")) {
                return match;
            }
            const serviceNameConstant = `\n    export const ServiceName = '${namespaceName}.Service' as const;`;
            return `export namespace ${namespaceName} {${serviceNameConstant}${content}}`;
        }
    );

    return result;
}

// Allow running directly
if (require.main === module) {
    generateTypes().catch(err => {
        console.error('Error generating types:', err);
        process.exit(1);
    });
}
